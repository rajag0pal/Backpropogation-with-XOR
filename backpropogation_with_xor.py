# -*- coding: utf-8 -*-
"""Backpropogation_with_XOR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xT_iWkkFEaFgUahpSrwFZxk_P7rt3gTf

### ***Implement Backpropogation algorithm for XOR and use variable Bias***

# Libraries
"""

import numpy as np

inputs = np.array([[0,0],[0,1],[1,0],[1,1]])
expected_output = np.array([[0],[1],[1],[0]])

#epoch = 1
import numpy as np 

def sigmoid (x):
    return 1/(1 + np.exp(-x))
    #return x

## XOR Data Set
inputs = np.array([[0,0],[0,1],[1,0],[1,1]])
expected_output = np.array([[0],[1],[1],[0]])

epochs = 50000
alpha = 0.01


## Initializing Hidden Layer Weight & Output Layer weights
#hidden_weights = np.zeros([2, 2])  ## 2 Inputs and 2 Hidden
#output_weights = np.zeros([2, 1])  ## 2 Hidden and 1 Output
hidden_weights = np.random.random(size=(2,2))
output_weights = np.random.random(size=(2,1))

#Variable Bias
b1 = float(np.random.random(size = (1)))
b2 = float(np.random.random(size = (1)))
bias_hidden = [b1,b2]
bias_output = np.random.random(size = (1))

print('Hidden: ',hidden_weights)
print('Output: ',output_weights)


## Training Algorithm for XOR 
for _ in range(epochs):
	
  ## Forward Propagation
  hidden_layer_net = np.dot(inputs,hidden_weights)+bias_hidden
  hidden_layer_output = sigmoid(hidden_layer_net)

  output_layer_net = np.dot(hidden_layer_output,output_weights)+bias_output
  predicted_output = sigmoid(output_layer_net)

  
	## Backpropagation
  error = expected_output - predicted_output
  #print(error)
	
	## Weight Update
  #output_weights = output_weights + (hidden_layer_output.T.dot(error) * alpha)
  #hidden_weights = hidden_weights + (error.T.dot(inputs) * alpha)

  output_weights_old = output_weights.copy()

  delta_predicted_output = (predicted_output.dot((1-predicted_output).T)).dot(error)
  ch_output_weights = alpha*((delta_predicted_output.T).dot(hidden_layer_output)).T
  output_weights = output_weights + ch_output_weights

  delta_hidden_layer_output = (hidden_layer_output.dot((1 - hidden_layer_output).T)).dot((output_weights_old.dot(delta_predicted_output.T)).T)
  ch_hidden_weights = alpha*((delta_hidden_layer_output.T).dot(inputs))
  hidden_weights = hidden_weights + ch_hidden_weights

print(predicted_output.round())
print('\n',error)
#print('\n------------')

#epoch = 2
import numpy as np 

def sigmoid (x):
    return 1/(1 + np.exp(-x))
    #return x

## XOR Data Set
inputs = np.array([[0,0],[0,1],[1,0],[1,1]])
expected_output = np.array([[0],[1],[1],[0]])

epochs = 50000
alpha = 0.01


## Initializing Hidden Layer Weight & Output Layer weights
#hidden_weights = np.zeros([2, 2])  ## 2 Inputs and 2 Hidden
#output_weights = np.zeros([2, 1])  ## 2 Hidden and 1 Output
hidden_weights = np.random.random(size=(2,2))
output_weights = np.random.random(size=(2,1))

#Variable Bias
b1 = float(np.random.random(size = (1)))
b2 = float(np.random.random(size = (1)))
bias_hidden = [b1,b2]
bias_output = np.random.random(size = (1))

print('Hidden: ',hidden_weights)
print('Output: ',output_weights)


## Training Algorithm for XOR 
for _ in range(epochs):
	
  ## Forward Propagation
  hidden_layer_net = np.dot(inputs,hidden_weights)+bias_hidden
  hidden_layer_output = sigmoid(hidden_layer_net)

  output_layer_net = np.dot(hidden_layer_output,output_weights)+bias_output
  predicted_output = sigmoid(output_layer_net)

  
	## Backpropagation
  error = expected_output - predicted_output
  #print(error)
	
	## Weight Update
  #output_weights = output_weights + (hidden_layer_output.T.dot(error) * alpha)
  #hidden_weights = hidden_weights + (error.T.dot(inputs) * alpha)

  output_weights_old = output_weights.copy()

  delta_predicted_output = (predicted_output.dot((1-predicted_output).T)).dot(error)
  ch_output_weights = alpha*((delta_predicted_output.T).dot(hidden_layer_output)).T
  output_weights = output_weights + ch_output_weights

  delta_hidden_layer_output = (hidden_layer_output.dot((1 - hidden_layer_output).T)).dot((output_weights_old.dot(delta_predicted_output.T)).T)
  ch_hidden_weights = alpha*((delta_hidden_layer_output.T).dot(inputs))
  hidden_weights = hidden_weights + ch_hidden_weights

print(predicted_output.round())
print('\n',error)
#print('\n------------')
